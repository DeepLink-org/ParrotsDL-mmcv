#include <float.h>
#include "common_mlu_helper.hpp"
#include <bang.h>
#include <sys/time.h>
#include <iostream>
__nram__ char nram_buffer[MAX_NRAM_SIZE];

namespace forward {

template <typename T>
__mlu_func__ void dmcn_im2col_bilinear(const T *input, const int data_width,
                                    const int height, const int width, T h, T w,
                                    const int c, const int num_channels, T* val, T* temp,
                                    const int channel_per_deformable_group, const int channel_per_group_align) {
    int h_low = floorf(h);
    int w_low = floorf(w);
    int h_high = h_low + 1;
    int w_high = w_low + 1;

    T lh = h - h_low;
    T lw = w - w_low;
    T hh = 1 - lh, hw = 1 - lw;

    T* v1 = temp;
    T* v2 = v1 + channel_per_group_align;
    T* v3 = v2 + channel_per_group_align;
    T* v4 = v3 + channel_per_group_align;
    __nramset(v1, channel_per_group_align, (T)0);
    __nramset(v2, channel_per_group_align, (T)0);
    __nramset(v3, channel_per_group_align, (T)0);
    __nramset(v4, channel_per_group_align, (T)0);

    if (h_low >= 0 && w_low >= 0) {
        __memcpy_async(v1, input + (h_low * data_width + w_low) * num_channels + c, channel_per_group_align * sizeof(T), GDRAM2NRAM);
    }
    if (h_low >= 0 && w_high <= width - 1) {
        __memcpy_async(v2, input + (h_low * data_width + w_high) * num_channels + c, channel_per_group_align * sizeof(T), GDRAM2NRAM);
    }
    if (h_high <= height - 1 && w_low >= 0) {
        __memcpy_async(v3, input + (h_high * data_width + w_low) * num_channels + c, channel_per_group_align * sizeof(T), GDRAM2NRAM);
    }
    if (h_high <= height - 1 && w_high <= width - 1) {
        __memcpy_async(v4, input + (h_high * data_width + w_high) * num_channels + c, channel_per_group_align * sizeof(T), GDRAM2NRAM);
    }
    __asm__ volatile("sync;");

    T w1 = hh * hw, w2 = hh * lw, w3 = lh * hw, w4 = lh * lw;
    __bang_mul_const(v1, v1, w1, channel_per_group_align);
    __bang_mul_const(v2, v2, w2, channel_per_group_align);
    __bang_mul_const(v3, v3, w3, channel_per_group_align);
    __bang_mul_const(v4, v4, w4, channel_per_group_align);

    __bang_add(val, v1, v2, channel_per_group_align);
    __bang_add(val, val, v3, channel_per_group_align);
    __bang_add(val, val, v4, channel_per_group_align);
}

template <typename T>
__mlu_func__ void modulated_deformable_im2col_camb_block(
        const int core_nums, const T *data_im, const T *data_offset, const T *data_mask,
        const int height, const int width, const int kernel_h, const int kernel_w,
        const int pad_h, const int pad_w, const int stride_h, const int stride_w,
        const int dilation_h, const int dilation_w,
        const int channel_per_deformable_group, const int batch_size,
        const int num_channels, const int deformable_group, const int height_col,
        const int width_col, T *data_col) {
    uint32_t idx = taskId;
    const int hw_col = height_col * width_col;
    if (idx >= hw_col) return;

    const int kernel_num = kernel_h * kernel_w;
    const T *data_im_ptr = data_im;
    const uint32_t nfu_align_num = NFU_ALIGN_SIZE / sizeof(T);
    const uint32_t channel_per_group_align = CEIL_ALIGN(channel_per_deformable_group, nfu_align_num);

    // batch_size must be 1
    for (uint32_t index = idx; index < hw_col; index += core_nums) {
        const uint32_t h_col = index / width_col;
        const uint32_t w_col = index % width_col;
        const int h_in = h_col * stride_h - pad_h;
        const int w_in = w_col * stride_w - pad_w;

        for (int i = 0; i < kernel_h; ++i) {
            for (int j = 0; j < kernel_w; ++j) {
                for(int deformable_group_index = 0; deformable_group_index < deformable_group; deformable_group_index++) {
                    int c_im = deformable_group_index * channel_per_deformable_group;
                    T *data_col_ptr =
                        data_col + (((i * kernel_w + j) * height_col + h_col) * width_col + w_col) * num_channels + c_im;
                    const T *data_offset_ptr =
                        data_offset + deformable_group_index * 2 * kernel_num * hw_col;
                    const T *data_mask_ptr =
                        data_mask + deformable_group_index * kernel_num * hw_col;
                    const int data_offset_h_ptr =
                        ((2 * (i * kernel_w + j)) * height_col + h_col) * width_col + w_col;
                    const int data_offset_w_ptr =
                        ((2 * (i * kernel_w + j) + 1) * height_col + h_col) * width_col + w_col;
                    const int data_mask_hw_ptr =
                        ((i * kernel_w + j) * height_col + h_col) * width_col + w_col;

                    const T offset_h = data_offset_ptr[data_offset_h_ptr];
                    const T offset_w = data_offset_ptr[data_offset_w_ptr];
                    const T mask = data_mask_ptr[data_mask_hw_ptr];
                    const T h_im = h_in + i * dilation_h + offset_h;
                    const T w_im = w_in + j * dilation_w + offset_w;

                    T* val = (T*)nram_buffer;
                    T* temp = val + channel_per_group_align;
                    __nramset(val, channel_per_group_align, (T)0);
                    if (h_im > -1 && w_im > -1 && h_im < height && w_im < width) {
                        dmcn_im2col_bilinear(data_im_ptr, width, height, width, h_im, w_im, c_im, num_channels,
                                             val, temp, channel_per_deformable_group, channel_per_group_align);
                    }
                    __bang_mul_const(val, val, mask, channel_per_group_align);
                    __asm__ volatile("sync;");
                    __memcpy_async(data_col_ptr, val, channel_per_deformable_group * sizeof(T), NRAM2GDRAM);
                }
            }
        }
        
    }
}

template <typename T>
__mlu_global__ void modulated_deformable_im2col_camb_kernel(
        const int core_nums, const void *data_im, const void *data_offset, const T *data_mask,
        const int height, const int width, const int kernel_h, const int kernel_w,
        const int pad_h, const int pad_w, const int stride_h, const int stride_w,
        const int dilation_h, const int dilation_w,
        const int channel_per_deformable_group, const int batch_size,
        const int num_channels, const int deformable_group, const int height_col,
        const int width_col, void *data_col) {
    modulated_deformable_im2col_camb_block(
        core_nums, (const T*)data_im, (const T*)data_offset, (const T*)data_mask,
        height, width, kernel_h, kernel_w,
        pad_h, pad_w, stride_h, stride_w,
        dilation_h, dilation_w,
        channel_per_deformable_group, batch_size,
        num_channels, deformable_group, height_col,
        width_col, (T*)data_col
    );
}

}  // namespace forward

void modulated_deformable_im2col_camb(
        cnrtDim3_t k_dim, cnrtFunctionType_t k_type, cnrtQueue_t queue, const cnrtDataType_t d_type,
        const void* data_im, const void* data_offset, const void* data_mask,
        const int batch_size, const int channels, const int height_im,
        const int width_im, const int height_col, const int width_col,
        const int kernel_h, const int kernel_w, const int pad_h, const int pad_w,
        const int stride_h, const int stride_w, const int dilation_h,
        const int dilation_w, const int deformable_group, void* data_col) {

    const int channel_per_deformable_group = channels / deformable_group;
    const int core_nums = k_dim.x * k_dim.y * k_dim.z;
    if (batch_size != 1) {
        printf("batch_size must be 1\n");
    }
    if (d_type == CNRT_FLOAT16) {
        forward::modulated_deformable_im2col_camb_kernel<
            half><<<k_dim, k_type, queue>>>(core_nums, (const half*)data_im, (const half*)data_offset, (const half*)data_mask,
                                            height_im, width_im, kernel_h, kernel_w,
                                            pad_h, pad_w, stride_h, stride_w,
                                            dilation_h, dilation_w,
                                            channel_per_deformable_group, batch_size,
                                            channels, deformable_group, height_col,
                                            width_col, (half*)data_col);
    } else {
        forward::modulated_deformable_im2col_camb_kernel<
            float><<<k_dim, k_type, queue>>>(core_nums, (const float*)data_im, (const float*)data_offset, (const float*)data_mask,
                                            height_im, width_im, kernel_h, kernel_w,
                                            pad_h, pad_w, stride_h, stride_w,
                                            dilation_h, dilation_w,
                                            channel_per_deformable_group, batch_size,
                                            channels, deformable_group, height_col,
                                            width_col, (float*)data_col);
    }
}

#include <float.h>
#include "common_mlu_helper.hpp"

namespace forward {

template <typename T>
__mlu_func__ T dmcn_im2col_bilinear(const T *input, const int data_width,
                                  const int height, const int width, T h, T w) {
    int h_low = floorf(h);
    int w_low = floorf(w);
    int h_high = h_low + 1;
    int w_high = w_low + 1;

    T lh = h - h_low;
    T lw = w - w_low;
    T hh = 1 - lh, hw = 1 - lw;

    T v1 = 0;
    if (h_low >= 0 && w_low >= 0) {
        v1 = input[h_low * data_width + w_low];
    }
    T v2 = 0;
    if (h_low >= 0 && w_high <= width - 1) {
        v2 = input[h_low * data_width + w_high];
    }
    T v3 = 0;
    if (h_high <= height - 1 && w_low >= 0) {
        v3 = input[h_high * data_width + w_low];
    }
    T v4 = 0;
    if (h_high <= height - 1 && w_high <= width - 1) {
        v4 = input[h_high * data_width + w_high];
    }

    T w1 = hh * hw, w2 = hh * lw, w3 = lh * hw, w4 = lh * lw;

    T val = (w1 * v1 + w2 * v2 + w3 * v3 + w4 * v4);
    return val;
}

template <typename T>
__mlu_func__ void modulated_deformable_im2col_camb_block(
        const int n, const int core_nums, const T *data_im, const T *data_offset, const T *data_mask,
        const int height, const int width, const int kernel_h, const int kernel_w,
        const int pad_h, const int pad_w, const int stride_h, const int stride_w,
        const int dilation_h, const int dilation_w,
        const int channel_per_deformable_group, const int batch_size,
        const int num_channels, const int deformable_group, const int height_col,
        const int width_col, T *data_col) {
    uint32_t idx = taskId;
    if (idx >= n) return;

    for (uint32_t index = idx; index < n; index += core_nums) {
        // index index of output matrix
        const int w_col = index % width_col;
        const int h_col = (index / width_col) % height_col;
        const int b_col = (index / width_col / height_col) % batch_size;
        const int c_im = (index / width_col / height_col) / batch_size;
        const int c_col = c_im * kernel_h * kernel_w;

        // compute deformable group index
        const int deformable_group_index = c_im / channel_per_deformable_group;

        const int h_in = h_col * stride_h - pad_h;
        const int w_in = w_col * stride_w - pad_w;

        T *data_col_ptr =
            data_col + ((c_col * batch_size + b_col) * height_col + h_col) * width_col + w_col;
        const T *data_im_ptr =
            data_im + (b_col * num_channels + c_im) * height * width;
        const T *data_offset_ptr =
            data_offset + (b_col * deformable_group + deformable_group_index) * 2 *
                            kernel_h * kernel_w * height_col * width_col;

        const T *data_mask_ptr =
            data_mask + (b_col * deformable_group + deformable_group_index) *
                            kernel_h * kernel_w * height_col * width_col;

        for (int i = 0; i < kernel_h; ++i) {
            for (int j = 0; j < kernel_w; ++j) {
                const int data_offset_h_ptr =
                    ((2 * (i * kernel_w + j)) * height_col + h_col) * width_col + w_col;
                const int data_offset_w_ptr =
                    ((2 * (i * kernel_w + j) + 1) * height_col + h_col) * width_col + w_col;
                const int data_mask_hw_ptr =
                    ((i * kernel_w + j) * height_col + h_col) * width_col + w_col;
                const T offset_h = data_offset_ptr[data_offset_h_ptr];
                const T offset_w = data_offset_ptr[data_offset_w_ptr];
                const T mask = data_mask_ptr[data_mask_hw_ptr];
                T val = static_cast<T>(0);
                const T h_im = h_in + i * dilation_h + offset_h;
                const T w_im = w_in + j * dilation_w + offset_w;
                if (h_im > -1 && w_im > -1 && h_im < height && w_im < width) {
                    val = dmcn_im2col_bilinear(data_im_ptr, width, height, width, h_im, w_im);
                }
                *data_col_ptr = val * mask;
                data_col_ptr += batch_size * height_col * width_col;
            }
        }
    }
}

template <typename T>
__mlu_global__ void modulated_deformable_im2col_camb_kernel(
        const int n, const int core_nums, const void *data_im, const void *data_offset, const T *data_mask,
        const int height, const int width, const int kernel_h, const int kernel_w,
        const int pad_h, const int pad_w, const int stride_h, const int stride_w,
        const int dilation_h, const int dilation_w,
        const int channel_per_deformable_group, const int batch_size,
        const int num_channels, const int deformable_group, const int height_col,
        const int width_col, void *data_col) {
    modulated_deformable_im2col_camb_block(
        n, core_nums, (const T*)data_im, (const T*)data_offset, (const T*)data_mask,
        height, width, kernel_h, kernel_w,
        pad_h, pad_w, stride_h, stride_w,
        dilation_h, dilation_w,
        channel_per_deformable_group, batch_size,
        num_channels, deformable_group, height_col,
        width_col, (T*)data_col
    );
}

}  // namespace forward

void modulated_deformable_im2col_camb(
        cnrtDim3_t k_dim, cnrtFunctionType_t k_type, cnrtQueue_t queue, const cnrtDataType_t d_type,
        const void* data_im, const void* data_offset, const void* data_mask,
        const int batch_size, const int channels, const int height_im,
        const int width_im, const int height_col, const int width_col,
        const int kernel_h, const int kernel_w, const int pad_h, const int pad_w,
        const int stride_h, const int stride_w, const int dilation_h,
        const int dilation_w, const int deformable_group, void* data_col) {

    const int channel_per_deformable_group = channels / deformable_group;
    const int num_kernels = channels * batch_size * height_col * width_col;
    const int core_nums = k_dim.x * k_dim.y * k_dim.z;
    if (d_type == CNRT_FLOAT16) {
        forward::modulated_deformable_im2col_camb_kernel<
            half><<<k_dim, k_type, queue>>>(num_kernels, core_nums, (const half*)data_im, (const half*)data_offset, (const half*)data_mask,
                                            height_im, width_im, kernel_h, kernel_w,
                                            pad_h, pad_w, stride_h, stride_w,
                                            dilation_h, dilation_w,
                                            channel_per_deformable_group, batch_size,
                                            channels, deformable_group, height_col,
                                            width_col, (half*)data_col);
    } else {
        forward::modulated_deformable_im2col_camb_kernel<
            float><<<k_dim, k_type, queue>>>(num_kernels, core_nums, (const float*)data_im, (const float*)data_offset, (const float*)data_mask,
                                            height_im, width_im, kernel_h, kernel_w,
                                            pad_h, pad_w, stride_h, stride_w,
                                            dilation_h, dilation_w,
                                            channel_per_deformable_group, batch_size,
                                            channels, deformable_group, height_col,
                                            width_col, (float*)data_col);
    }
}